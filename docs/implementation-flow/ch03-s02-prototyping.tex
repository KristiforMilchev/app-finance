% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

\subsection{[TBD] Prototyping Application Skeleton}
\markboth{Implementing Core Functionality}{Prototyping Application Skeleton}

[TBD]

\subsubsection{Creating Widget Tests} \label{widget-tests}

By now we've created some business logic functionality with not so trivial flow. Not to waste the time on checking it
all the time manually after significant changes or refactoring, let's create some tests to check it for us automatically.

Furthermore we've already broken our first test (that's been provided by a Flutter template generation). At the 
beginning it was covering the `Add`-button as an incremental trigger for the shown counter.

\begin{lstlisting}
void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}
\end{lstlisting}

\noindent Let's check that `Add`-button is opening a Widget with a three named tabs.

\begin{lstlisting}
void main() {
  testWidgets('Given Main page When tap on Create Then opened BillAddPage', (WidgetTester tester) async {
    // App initialization
    await tester.pumpWidget(
        // Taken as is from `void main` of `lib/main.dart`-file
        ChangeNotifierProvider(
            create: (_) => AppData(),
            child: const MyApp(),
        )
    );
    // Checking one of the text widgets
    expect(find.text('Goals'), findsOneWidget);
    // Clicking on `Add`-button
    await tester.tap(find.byIcon(Icons.add));
    await tester.pumpAndSettle(); // Waiting till finished render state
    // Asserting icons on our tabs
    expect(find.byIcon(Icons.insert_invitation), findsOneWidget);
    expect(find.byIcon(Icons.money_off), findsOneWidget);
    expect(find.byIcon(Icons.transform), findsOneWidget);
  });
}
\end{lstlisting}

Here we are, by `tab` and `expect` the flow of the whole application can be checked. Such type of tests are named as 
Widget tests that emphasized by specially named `testWidgets`-function.

Initially, it would be better to concentrate mostly on Business Logic than on the draft state of our pages. We'll 
return later to UI/UX, redesign if not dramatically but vastly, and right after that write a reliable 
Test Suite for the Widgets. To check business based calculations it's used `test`-function, and, by example, we would
take our implemented Account Recalculation flow.

\begin{lstlisting}
// test/unit/_classes/data/account_recalculation_test.dart 
void main() {
  // `group` works as a prefix to all the tests inside
  group('Account Recalculation:getDelta', () {
    late AccountRecalculation mock; // Deferred initialization 
    // `setUp` - is going to be executed before each test
    // `setUpAll` - once at the beginning of group evaluation
    setUp(() {
      final accountMock = AccountAppData(
        uuid: '1',
        title: 'test',
        type: AppAccountType.account.toString(),
      );
      mock = AccountRecalculation(
        initial: accountMock.clone(),
        change: accountMock.clone(),
      );
    });
    // Define "table" of input arguments and output assertions
    final testCases = [
      // initial  |   change   | result
      [false, 5.0,  false, 1.0,  -4.0],
      [false, 1.0,  false, 5.0,   4.0],
      [true,  2.0,  false, 3.0,   3.0],
      [false, 2.0,  true,  3.0,  -2.0],
    ];
    // Run all defined Test Cases
    for (var v in testCases) {
      test('initial(hidden[${v[0]}], details[${v[1]}]), change(hidden[${v[2]}], details[${v[3]}]) => ${v[4]}', () {
        // Update inputs
        mock.initial!.hidden = v[0] as bool;
        mock.initial!.details = v[1] as double;
        mock.change.hidden = v[2] as bool;
        mock.change.details = v[3] as double;
        // Assert `AccountRecalculation.getDelta`-method results
        expect(mock.getDelta(), v[4]); 
      });
    }
  });
}
\end{lstlisting}

By typing `flutter test` in the command line we would see something like that:

\begin{lstlisting}
[V] Given Main page When tap on Create Then opened BillAddPage
[V] Account Recalculation:getDelta initial(hidden[false], details[5.0]), change(hidden[false], details[1.0]) => -4.0
[V] Account Recalculation:getDelta initial(hidden[false], details[1.0]), change(hidden[false], details[5.0]) => 4.0
Expected: <3.0>
  Actual: <1.0>
[X] Account Recalculation:getDelta initial(hidden[true], details[2.0]), change(hidden[false], details[3.0]) => 3.0
[V] Account Recalculation:getDelta initial(hidden[false], details[2.0]), change(hidden[true], details[3.0]) => -2.0
Null check operator used on a null value
[X] Account Recalculation:getDelta initial(null), change(hidden[false], details[2.0]) => 2.0
Exited (1)
\end{lstlisting}

\noindent That test has highlighted a dozen of troubles and failures in our code, so, it definitely has not been 
written in vain.

\begin{lstlisting}[firstnumber=17]
// ./lib/_classes/data/account_recalculation.dart
double getDelta() {
  return change.hidden
\end{lstlisting}
{
\xpretocmd{\lstlisting}{\vspace{-12pt}}{}{}
\begin{lstlisting}[firstnumber=20, backgroundcolor=\color{backred}]
(*@\kdiff{-}@*)  ? -initial!.details
\end{lstlisting}
\begin{lstlisting}[firstnumber=20, backgroundcolor=\color{backgreen}]
(*@\kdiff{+}@*)  ? -(initial?.details ?? 0.0)
\end{lstlisting}
\begin{lstlisting}[firstnumber=21, backgroundcolor=\color{backred}]
(*@\kdiff{-}@*)  : change.details - initial!.details;
\end{lstlisting}
\begin{lstlisting}[firstnumber=21, backgroundcolor=\color{backgreen}]
(*@\kdiff{+}@*)  : (initial?.hidden ?? true
(*@\kdiff{+}@*)      ? change.details
(*@\kdiff{+}@*)      : change.details - initial?.details);
\end{lstlisting}
\begin{lstlisting}[firstnumber=24]
}
\end{lstlisting}
}

\subsubsection{Creating Automated Quality Gates}

Tests writing is not enough for a quality check, we have to implement some dozen of automation till the phase 
when will become too lazy to trigger that manually. In addition, Flutter provides a couple of commands for the 
code improvement:
\begin{lstlisting}
flutter analyze // Static analysis of Dart code
dart format // Apply rules from https://dart.dev/effective-dart/style#formatting
dart fix // Check what can be improved, by `--apply` will change the code
\end{lstlisting}


\paragraph{Creating Git Hooks}

Someone might think that additional checks before `git commit` and `git push` will slowdown the development process, 
contrary that minimizes pushes back and forward to resolve failures on CI/CD build procedure. For a really big projects
that might take hours in contrast with seconds on local environment. Surely, the automation process has to be done
accurately and properly, otherwise it will be constantly bored.

Implementing git hooks is a preparation of bash-scripts for execution, so, let's discuss here `pre-push`-file (since
`pre-commit`-file contains almost the same logic for another scope of commands).

\begin{lstlisting}[language=bash]
#!/bin/bash

status=0

flutter test # Trigger tests
status_test=$? # Take status for lastly executed command

if [ $status_test -ne 0 ]; then
  echo "[x] flutter test - failed."
  status=1
else
  echo "[+] flutter test - passed."
fi

exit $status
\end{lstlisting}

\noindent Let's use Grinder to install our hooks (`dart run grinder:init` can be used to generate a skeleton 
structure if it's missing yet).

\begin{lstlisting}
// ./tool/grind.dart
import 'dart:io';
import 'package:path/path.dart' as path;
import 'package:grinder/grinder.dart';

main(args) => grind(args);

@Task('Install Git Hooks')
installGitHooks() {
  final currDir = Directory('./');
  final hookDir = Directory('./.git/hooks');
  final hookNames = ['pre-commit', 'pre-push'];
  for (final name in hookNames) {
    log('Applying: $name');
    final sourceFile = File(path.join(currDir.absolute.path, name));
    sourceFile.copySync(path.join(hookDir.absolute.path, name));
  }
  log('Git Hooks applied!');
}
\end{lstlisting}

\noindent After that by using command line, let's check what we have:

\begin{lstlisting}[language=bash]
$ dart run grinder -h
Dart workflows, automated.

Usage: grinder [options] [<tasks>...]

Global options:
  --no-color           Whether to use terminal colors.
  --version            Reports the version of this tool.
  -h, --help           Print this usage information.

Available tasks:
  install-git-hooks    Install Git Hooks
  sort-translations    Update Translations by sorting values alphabetically

$ dart run grinder install-git-hooks
  grinder running install-git-hooks
  
  install-git-hooks
    Applying: pre-commit
    Applying: pre-push
    Git Hooks applied!
  
  finished in 0.0 seconds

$ git add .
$ git commit -m "Sample Commit"
Computing fixes in app-finance (dry run)...
Nothing to fix!
Formatted 56 files (0 changed) in 0.42 seconds.

[+] dart fix - passed.
[+] dart format - passed.
[+] dart run grinder sort-translations - passed.
Sample Commit
 3 files changed, 65 insertions(+), 90 deletions(-)

$ git push
# ... logs from tests
[+] flutter test - passed.
# ... other logs from git
\end{lstlisting}


\paragraph{Adding Grinder Helpers}

We haven't yet discussed our `grinder sort-translations` that was shown through the logs above. That task is needed
to automatically rearrange our labels in `/lib/l10n/app\_*.arb`-files. We might extend our grinder tasks lately
by also checking consistency (enter missing labels across the `.arb`-files), exporting labels to `.scv`-file
for translation purposes, and importing them back.

\begin{lstlisting}
// ./tool/grind.dart
import './localization.dart' as locale;

@Task('Update Translations by sorting values alphabetically')
sortTranslations() {
  // Get all additional arguments for the command
  TaskArgs args = context.invocation.arguments;
  // Run: dart run grinder sort-translations --quiet
  bool isQuiet = args.getFlag('quiet'); // Returns `true` if set
  bool isChanged = locale.sortArbKeys('./lib/l10n');
  if (isChanged && !isQuiet) {
    fail('Changes detected'); // (!) to handle failure
  }
}
\end{lstlisting}

\begin{lstlisting}
// ./tool/localization.dart
import 'dart:convert';
import 'dart:io';
import 'package:grinder/grinder.dart';

bool sortArbKeys(String path) {
  log('Checking $path'); // Add to console output the text
  final arbDir = Directory(path);
  bool isChanged = false;
  // Check, that folder is not missing
  if (!arbDir.existsSync()) {
    log('Error: Directory not found');
    return true;
  }
  // Loop per each file there
  for (var file in arbDir.listSync()) {
    // Take only .arb-files
    if (file is File && file.path.endsWith('.arb')) {
      log('- ${file.path}');
      // `|=` is a boolean OR assignment
      isChanged |= sortArbFileKeys(file);
    }
  }
  log(isChanged ? 'Labels reordered' : 'Nothing was changed');
  return isChanged;
}

bool sortArbFileKeys(File file) {
  // Load data from file
  final jsonContent = file.readAsStringSync();
  final arbMap = json.decode(jsonContent) as Map<String, dynamic>;
  // Sort labels
  final entries = arbMap.entries.toList();
  entries.sort((a, b) {
    final aKey = a.key.startsWith('@') ? a.key.substring(1) : a.key;
    final bKey = b.key.startsWith('@') ? b.key.substring(1) : b.key;
    return aKey.compareTo(bKey);
  });
  final sortedArbMap = Map.fromEntries(entries);
  // Write back to the file with preserved indentation
  const encoder = JsonEncoder.withIndent('    ');
  var jsonOutputContent = encoder.convert(sortedArbMap);
  file.writeAsStringSync(jsonOutputContent);
  return jsonOutputContent != jsonContent; // Check if changed
}
\end{lstlisting}


\paragraph{Activating GitHub Workflow}

We've done with our automation for local environment, let's go further and define quality gates on GitHub repository.

\begin{lstlisting}[language=yaml]
# ./.github/workflows/dart.yml
name: Flutter/Dart Quality Gates # Name that would be shown in Actions tab

on:
  push: # Trigger after a merge
    branches: [ "main" ] # limit to main-branch
  pull_request: # Trigger on pull-request
    branches: [ "main" ] # if the target is main-branch

jobs:
  build:
    runs-on: ubuntu-latest # Environment for execution

    steps:
      - uses: actions/checkout@v3 # Checkout from repository
      - uses: subosito/flutter-action@v2 # Install Flutter/Dart
        with:
          channel: 'stable'
      - run: flutter --version # Show version in logs

      - name: Install Dependencies
        run: flutter pub get

      - name: Verify Formatting
        run: dart format --output=none --set-exit-if-changed .

      - name: Check Localizations ordering
        run: dart run grinder sort-translations

      # Consider passing '--fatal-infos' for slightly stricter analysis.
      - name: Analyze Project Source
        run: flutter analyze

      - name: Run tests
        run: flutter test
\end{lstlisting}

\noindent By preparing a pull-request we would see next representative validations flow 
(\cref{img:pt-github}, \cref{img:pt-github-details})):

\img{prototyping/github-check}{GitHub Toolbar on pull-request}{img:pt-github}

\img{prototyping/github-check-details}{GitHub Workflow Actions details}{img:pt-github-details}

In which way we can improve the current state is to gratitude ourselves by Badges of Workflow Status and Code Coverage.

\begin{lstlisting}[language=bash]
# ./README.md
# Notation of an image with tooltip "Build Status" 
![Build Status](https://github.com/{user}/{repo}/actions/workflows/{workflow-name}.yml/badge.svg?branch=main)
# Notation of an image with a link to our repository
[![Tests Coverage](https://{user}.github.io/{repo}/coverage_badge.svg)](https://github.com/{user}/{repo})
\end{lstlisting}

`Build Status` is supported out of the box (OOTB) by GitHub, just it's needed to replace `\{user\}` (account name
on GitHub), `\{repo\}` (repository name), and `\{workflow-name\}` (name of the file in `.github/workflows`-folder).

`Test Coverage` is needed to be cooked (there are many ways to do that and none of them is universal), and we're 
starting from creating `gh-pages` for our repository (drop hooks from `.git/hooks`-folder if they've been enabled):

\begin{lstlisting}[language=bash]
git switch --orphan gh-pages
git commit --allow-empty -m "Initial commit"
git push -u origin gh-pages
git checkout main
\end{lstlisting}

\noindent That will create for us a special branch that is accessible via \`https://\{user\}.github.io/\{repo\}\`-link. 
Then we need to extend our GitHub Workflow by including there a section to upload artifacts:

\begin{lstlisting}[language=yaml]
# ./.github/workflows/dart.yml
# Updating previously created step by a conditional execution
- name: Run tests
run: |
  if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
    flutter test --coverage
    dart run grinder coverage-badge # New Grinder task to generate `.svg'-file with coverage
  else
    flutter test
  fi
# New section to upload artifacts
- name: Update Coverage Badge
  # Get default branch variable and compare with current
  if: github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
  uses: peaceiris/actions-gh-pages@v3 # Special action to upload artifacts
  with:
    github_token: ${{ secrets.GITHUB_TOKEN }} # Generated automatically by GitHub
    publish_dir: ./coverage # Folder to upload
\end{lstlisting}

\img{prototyping/badges}{Generated README.md for the repository}{img:pt-badge}

Everything is done (\cref{img:pt-badge})... almost. Coverage 46\% is unbelievable for written tests. The problem is 
that untouched (by tests) files are not included into the report. And, additionally, widget tests cover most of the 
files without checking them. So, let's separate type of tests' execution, and provide additional Grinder task to 
touch all our files for the coverage report.

\begin{lstlisting}[language=yaml]
# ./.github/workflows/dart.yml
- name: Run tests
  run: |
    if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
      dart run grinder full-coverage
      flutter test --coverage test/unit
      flutter test test/widget
      dart run grinder coverage-badge
    else
      flutter test
    fi
\end{lstlisting}

\begin{lstlisting}
// ./tool/coverage.dart
import 'dart:io';
void scanDirectory(Directory directory, List<String> files) {
  directory.listSync(recursive: true).forEach((entity) {
    if (entity is File && // Check that it's a file
        entity.path.endsWith('.dart') && // Include only Dart
        !entity.path.endsWith('.g.dart')) { // Code generation
      files.add(entity.absolute.path
        .replaceAll(root.absolute.path, '') // Cut out root prefix
        .replaceAll('\\', '/')); // Fix for Windows' systems
    } else if (entity is Directory) {
      scanDirectory(entity, files); // Recursively scan further
    }
  });
}
\end{lstlisting}

\begin{lstlisting}
// ./tool/grind.dart
import './coverage.dart' as coverage;
@Task('Generate file with all lib/**.dart-files included')
fullCoverage() {
  List<String> files = [];
  String content = "// AUTOGENERATED BY `dart run grinder full-coverage` \n";
  final rootFolder = Directory('${Directory.current.path}/lib');
  coverage.scanDirectory(rootFolder, rootFolder, files);
  for (var file in files) {
    content += "import 'package:app_finance$file';\n";
  }
  content += "void main() {}\n";
  File(path.join(Directory.current.path, 'test/_coverage.dart')).writeAsStringSync(content);
}
\end{lstlisting}

\begin{lstlisting}[language=bash]
# .gitignore
# Coverage report
coverage/
test/_coverage.dart
\end{lstlisting}

\noindent 10\% Coverage... here we are. Slowly and progressively, we will correct this assessment but not immediately.
Do remember that we're on an early stage and nothing is neither stable, nor finalized yet.


\subsubsection{Creating Unit Tests with Wrappers (Code Generators)}

We've implemented earlier the test for a simple function that is isolated by itself from all other functionality. 
In most of the cases our functions are calling other functions, while unit test has to check the logic of the defined 
function isolately by cutting all external interactions (idealy, even within one class). To achieve that we might
use `Mockito` (\href{https://github.com/dart-lang/mockito}{https://github.com/dart-lang/mockito}):

\begin{lstlisting}
// ./test/unit/_classes/data/account_recalculation_test.dart
// Original class that we're testing
import 'package:app_finance/_classes/data/account_recalculation.dart';
// Wrapping our class by Mockito
@GenerateNiceMocks([MockSpec<AccountRecalculation>()])
import 'account_recalculation_test.mocks.dart';

void main() {
  group('AccountRecalculation updateGoals', () {
    late List<GoalAppData> goals;
    // Data initialization
    setUp(() {
      goals = [
        GoalAppData(title: '1', details: 25.0, progress: 0.0),
        GoalAppData(title: '2', details: 50.0, progress: 0.0),
        GoalAppData(title: '3', details: 100.0, progress: 0.0),
      ];
    });
    // Test Suite (Behavioral Matrix)
    final testCases = [
      (getDelta: 0.0, progress: [0.0, 0.0, 0.0], result: [0.0, 0.0, 0.0]),
      // ... other cases
    ];
    // Loop across all Test Cases
    for (var v in testCases) {
      test('$v', () {// Make test representation named by its inputs
        final mock = MockAccountRecalculation();
        // Wrap "external" method
        when(mock.getDelta()).thenReturn(v.getDelta);
        // Preparing data for the test
        for (int i = 0; i < v.progress.length; i++) {
          goals[i].progress = v.progress[i];
        }
        mock.updateGoals(goals);
        // Asserting results
        for (int i = 0; i < v.result.length; i++) {
          expect(goals[i].progress, v.result[i]);
        }
      });
    }
  });
}
\end{lstlisting}

Almost done... failing since `account\_recalculation\_test.mocks.dart`-file is missing. To resolve that we have to use 
additional a library `build\_runner` (`flutter pub add build\_runner --dev`) that will generate `*.mocks.dart`-files
for us. But that makes our work harder since before each `flutter test` we have to run `flutter run build\_runner build`.
Let's cover that by additional Grinder task:

\begin{lstlisting}
// ./tool/grind.dart
@Task('Generate Mocks')
mock() {
  ProcessResult build = Process.runSync('dart', [
    'run',
    'build_runner',
    'build',
    '--delete-conflicting-outputs',
  ]);
  if (build.exitCode > 0) {
    fail(build.stderr);
  }
}

@Task('Run tests')
@Depends(mock)
test() {
  TaskArgs args = context.invocation.arguments;
  ProcessResult test = Process.runSync(
    'flutter', 
    [
      'test',
      args.getFlag('coverage') ? '--coverage' : '',
      args.getOption('path') ?? ''
    ].where((e) => e != '').toList(), // Drop empty arguments 
    runInShell: true // Otherwise, error: The system cannot find the file specified. 
  );
  if (test.exitCode > 0) {
    fail(test.stderr);
  }
  log(test.stdout);
}
\end{lstlisting}

\begin{lstlisting}[language=bash]
> dart run grinder test
grinder running test

test
  [INFO] Generating build script...
  ...
  [INFO] Succeeded after 51ms with 0 outputs (0 actions)

  00:00 +0: AccountRecalculation updateGoals (getDelta: 0.0, ...
  ...
  00:01 +7: All tests passed!
\end{lstlisting}

\noindent The first test with mocks is passing, but not actually evaluate the original method as we might expect, 
everything is mocked! To achieve a capability of a partial mocking we would need to implement a wrapper around the 
original class. By using `mockGetDelta`-method it would be possible to override (mock) behavior of any method. 

\begin{lstlisting}
class WrapperAccountRecalculation extends AccountRecalculation {
  double Function()? _getDelta;
  // ignore: non_constant_identifier_names
  set mockGetDelta(double Function() value) {
    _getDelta = value;
  }

  @override
  double getDelta() => (_getDelta ?? super.getDelta)();
}
\end{lstlisting}

\noindent So, let's automated that part as well by using the `source\_gen` package, which provides capabilities to 
generate `.dart`-files based on annotations. Firstly, it's needed to register our custom builder via `build.yaml`-file:

\begin{lstlisting}[language=yaml]
# Force to activate our generator
targets:
  $default:
    builders: 
      # Combination of application name and builder definition
      app_finance|wrapper_generator:
        enabled: true # Activate its usage

builders:
  wrapper_generator: # Builder name
    # Builder file location
    import: "package:app_finance/_classes/gen/wrapper_generator.dart"
    # Method name that is used as a factory
    builder_factories: ["wrapperGenerator"]
    build_extensions: {".dart": [".wrapper.dart"]}
    auto_apply: dependents
    build_to: source # Generate to file
    applies_builders: ["source_gen|combining_builder"]
\end{lstlisting}

\begin{lstlisting}
// ./lib/_classes/gen/generate_with_method_setters.dart
class GenerateWithMethodSetters {
  final List<Type> classes;
  const GenerateWithMethodSetters([this.classes = const []]);
}(*@ \stopnumber @*)

// ./lib/_classes/gen/wrapper_generator.dart
Builder wrapperGenerator(BuilderOptions options) => LibraryBuilder(
      WrapperGenerator(),
      generatedExtension: '.wrapper.dart',
    );

class WrapperGenerator extends Generator {
  String build(Iterable<DartObject> annotations) {
    final result = StringBuffer();
    for (final annotation in annotations) {
      final classes = annotation.getField('classes');
      if (classes!.isNull) {
        break;
      }
      for (final name in classes.toListValue()!) {
        final type = name.toTypeValue();
        final classElement = type?.element as ClassElement;
        final visitor = WrapperVisitor(classElement);
        result.writeln(visitor.toString());
      }
    }
    return result.toString();
  }

  @override
  String generate(LibraryReader library, BuildStep buildStep) {
    final result = StringBuffer();
    for (final element in library.allElements) {
      final annotations =
          const TypeChecker.fromRuntime(GenerateWithMethodSetters)
              .annotationsOf(element);
      if (annotations.isNotEmpty) {
        result.writeln(build(annotations));
      }
    }
    return result.toString();
  }
}(*@ \stopnumber @*)
  
// ./lib/_classes/gen/wrapper_visitor.dart
class WrapperVisitor {
  StringBuffer buffer = StringBuffer();
  ClassElement element;

  WrapperVisitor(this.element);

  void addImports() {
    final mainClass = element.enclosingElement.library;
    addImport(mainClass);
    for (final cls in mainClass.importedLibraries) {
      addImport(cls);
    }
    buffer.writeln('');
  }

  void addImport(LibraryElement className) {
    buffer.writeln('// ignore: unused_import');
    buffer.writeln("import '${className.source.uri}';");
  }

  void addClassDefinition() {
    buffer.writeln('class Wrapper${element.name} extends ${element.name} {');
    final constructor = element.unnamedConstructor;
    if (!constructor!.isDefaultConstructor) {
      final properties = constructor.parameters;
      buffer.writeln('  Wrapper${element.name}({');
      if (properties.isNotEmpty) {
        for (var e in properties) {
          buffer.writeln(
              '    ${e.isRequired ? 'required ' : ''}super.${e.name},');
        }
      }
      buffer.writeln('  });');
    }
  }

  void addMethods() {
    for (final m in element.methods) {
      final args = m.parameters.map((e) => e.name).toList().join(', ');
      final name = 'mock${m.name[0].toUpperCase()}${m.name.substring(1)}';
      buffer.writeln('');
      buffer.writeln('  ${m.returnType} Function()? _${m.name};');
      buffer.writeln('  // ignore: non_constant_identifier_names');
      buffer.writeln('  set $name(${m.returnType} Function() value) {');
      buffer.writeln('    _${m.name} = value;');
      buffer.writeln('  }');
      buffer.writeln('');
      buffer.writeln('  @override');
      buffer.writeln('  $m => (_${m.name} ?? super.${m.name})($args);');
    }
  }

  void finalize() {
    buffer.writeln('}');
  }

  @override
  String toString() {
    addImports();
    addClassDefinition();
    addMethods();
    finalize();
    return buffer.toString();
  }
}
\end{lstlisting}

\noindent And, finally, or test would be adjusted to support implemented wrapper:

\begin{lstlisting}
@GenerateNiceMocks([MockSpec<AccountRecalculation>()])
import 'account_recalculation_test.mocks.dart';
@GenerateWithMethodSetters([AccountRecalculation])
import 'account_recalculation_test.wrapper.dart';

test('Demo', () {
  final mock = MockAccountRecalculation();
  final wrapper = WrapperAccountRecalculation();
  when(mock.getDelta()).thenReturn(v.getDelta);
  wrapper.mockGetDelta = mock.getDelta;
  for (int i = 0; i < v.progress.length; i++) {
    goals[i].progress = v.progress[i];
  }
  wrapper.updateGoals(goals);
  verify(mock.getDelta()).called(1);
  for (int i = 0; i < v.result.length; i++) {
    expect(goals[i].progress, v.result[i]);
  }
});
\end{lstlisting}


\subsubsection{Introducing Behavioral Tests (Gherkin)}

Improvement cycles are never ends. Previously (\ref{widget-tests}), we've discussed approach to test widgets and used 
`When ... Given ... Then ...`-notation. That notation is a part of Behavior-Driven Development (BDD), the process
of approaching the desired outcome on first place before the code. But we've used that notation as a comment that is 
useless without any interpreter (since it can be written one flow but tested totally different things; or, it's been 
forgotten to update the comment).

Cucumber (\href{https://docs.cucumber.io}{https://docs.cucumber.io}) is a practical standard, by being widely used, 
a testing framework for Behavior Driven Development.

Gherkin (\href{https://pub.dev/packages/gherkin}{https://pub.dev/packages/gherkin}), as a fully featured parser and 
test runner for Flutter and Dart, would be used by us to convert When/Given/Then(And/But) into a real test steps.

In Cucumber-JVM (as well as in Gherkin) calling steps from step definitions is not supported; this is by design. That's
why I do love Robot Framework (\href{https://robotframework.org}{https://robotframework.org}) that allows to create 
high-level scenarios by combining low-level steps. That limitation "by design" is made to not create a mess, with an 
assumption, that this may lead to an explosion of step definitions, code duplication, and high maintenance costs. We 
won't argue with highly-qualified specialists and take all the risks to our own. Testing is a variation of an art where 
a common sense is a mantra to succeed.

After adding it (`flutter pub add flutter\_gherkin --dev`) into our application, we can start from creation 
`.feature`-file to describe our scenario.

\begin{lstlisting}[language=cucumber]
@account @currency
Feature: Verify Account functionality alignment with expectations

  Scenario: Opened Account Form
    Given I am on "Main" page
    When I tap "Account" header
    And I tap "Create" button
    Then I can see "Account Form" component

  Scenario Outline: Created different Account types
    Given Opened Account Form
    When I fill the "Account" field with <type>
    Then I should see <fields> fields
    But not <hidden> fields

    Examples: 
      | type | fields | hidden |
      | ...  |  ...   |  ...   |
\end{lstlisting}

We've created Scenario "Opened Account Form" and by braking all the recommendations re-used it in Scenario Outline 
for `Given`-step. What's that giving us? To answer that question, let's check how a billing flow might look like:

\begin{lstlisting}[language=cucumber]
  Scenario Outline: Added different Expenses
    Given Created different Account types
    And Created different Budget types
    And Opened Expense Form
    When I fill the "Amount" field with <type>
    ...
    And I tap "Create" button
    Then I should see "Account <account>" deduction by <amount>
    And I should see "Budget <budget>" percentage change to <percent> with left <budget_amount>
\end{lstlisting}

So powerful simplification cannot be ignored, it's not a mess but extreme code-reusability and simplification. If
something would be changed (pipeline to open form, properties, widgets, etc.), a single scenario would be responsible 
for that. The only convention: scenario is written in past tense, step - in present. By following such a simple rule it 
would be always obvious the nested structure. 

Another drawback is that Gherkin runs User Interface tests (mostly known as Selenium tests) by compiling and running 
the original application with enabled Flutter Driver Extension that simulates user behavior. It's not something that we 
might be interested in by now, expecting their fast evaluation via simulation as it's done for widget tests. So, we're 
going to take an interpreter of `.feature`-files and use `flutter\_test`-package for all other stuff. Additional benefit
from that is that a basic Test Terminal in IDE would work for us with all features enabled (to run/re-run a single, a 
group or all tests) and we would still have a single entry point to evaluate all our tests.

But let's proceed iteratively, and implement wrapper around Gherkin to parse `.feature`-files and evaluate 
them (\cref{img:p-bdd}):

\begin{lstlisting}
./test/e2e/e2e_test.dart
void main() {
  // Taking all our .feature files
  late Iterable<File> scope = Directory('./test/e2e')
      .listSync(recursive: true)
      .where((entity) => entity is File && entity.path.endsWith('.feature'))
      .cast<File>();

  group('Behavioral Tests', () {
    for (var file in scope) {
      testWidgets(file.path, (WidgetTester tester) async {   
        await tester.pumpWidget(ChangeNotifierProvider(
          create: (_) => AppData(),
          child: const MyApp(),
        ));
        final runner = FileRunner(file);
        await runner.init();
        runner.run();
      });
    }
  });
}(*@ \stopnumber @*)

// ./test/e2e/_steps/file_runner.dart
class FileRunner {
  File file;
  final language = LanguageService();
  final parser = GherkinParser();
  final featureFile = FeatureFile(RunnableDebugInformation.EMPTY());
  late FeatureFileRunner runner;

  FileRunner(this.file) {
    language.initialise();
    runner = FeatureFileRunner(
      FlutterTestConfiguration(),
      TagExpressionEvaluator(),
      ExecutableStepIterator().aggregate(),
      ProgressReporter(),
      AggregatedHook(),
    );
  }

  Future<void> init() async {
    // Parsing taken file by Gherkin
    final parserResult = await parser.parseFeatureFile(
      file.readAsStringSync(),
      '',
      ProgressReporter(),
      language,
    );
    for (final feature in parserResult.features) {
      featureFile.addChild(feature);
    }
  }

  void run() {
    runner.run(featureFile);
  }
}(*@ \stopnumber @*)

// ./test/e2e/_steps/executable_step_iterator.dart
class ExecutableStepIterator {
  final List<CustomParameter> param = <CustomParameter>[];

  ExecutableStepIterator() {
    param.addAll([
      NumParameterLower(),
      IntParameterLower(),
      StringParameterLower(),
      WordParameterLower(),
    ]);
  }

  List<ExecutableStep> _register(List<dynamic> steps) {
    return steps.map(
      (s) => ExecutableStep(GherkinExpression(s.pattern, param), s),
    ).toList();
  }

  Iterable<ExecutableStep> aggregate() {
    return _register([
      // Given
      OnDefinedPage(),
      // When
      TapDefinedButton(),
      TapDefinedHeader(),
      // Then
      CanSeeDefinedComponent(),
    ]);
  }
}
\end{lstlisting}

\img{prototyping/bdd-test}{Behavioral Test evaluation}{img:p-bdd}