% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

\subsection{[TBD] Prototyping Application Skeleton}
\markboth{Implementing Core Functionality}{Prototyping Application Skeleton}

[TBD]

\subsubsection{Creating Unit Tests}

By now we've created some business logic functionality with not so trivial flow. Not to waste the time on checking it
all the time manually after significant changes or refactoring, let's create some tests to check it for us automatically.

Furthermore we've already broken our first test (that's been provided by a Flutter template generation). At the 
beginning it was covering the `Add`-button as an incremental trigger for the shown counter.

\begin{lstlisting}
void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}
\end{lstlisting}

\noindent Let's check that `Add`-button is opening a Widget with a three named tabs.

\begin{lstlisting}
void main() {
  testWidgets('Given Main page When tap on Create Then opened BillAddPage', (WidgetTester tester) async {
    // App initialization
    await tester.pumpWidget(
        // Taken as is from `void main` of `lib/main.dart`-file
        ChangeNotifierProvider(
            create: (_) => AppData(),
            child: const MyApp(),
        )
    );
    // Checking one of the text widgets
    expect(find.text('Goals'), findsOneWidget);
    // Clicking on `Add`-button
    await tester.tap(find.byIcon(Icons.add));
    await tester.pumpAndSettle(); // Waiting till finished render state
    // Asserting icons on our tabs
    expect(find.byIcon(Icons.insert_invitation), findsOneWidget);
    expect(find.byIcon(Icons.money_off), findsOneWidget);
    expect(find.byIcon(Icons.transform), findsOneWidget);
  });
}
\end{lstlisting}

Here we are, by `tab` and `expect` the flow of the whole application can be checked. Such type of tests are named as 
Widget tests that emphasized by specially named `testWidgets`-function.

Initially, it would be better to concentrate mostly on Business Logic than on the draft state of our pages. We'll 
return later to UI/UX, redesign if not dramatically but vastly, and right after that write a reliable 
Test Suite for the Widgets. To check business based calculations it's used `test`-function, and, by example, we would
take our implemented Account Recalculation flow.

\begin{lstlisting}
// test/unit/_classes/data/account_recalculation_test.dart 
void main() {
  // `group` works as a prefix to all the tests inside
  group('Account Recalculation:getDelta', () {
    late AccountRecalculation mock; // Deferred initialization 
    // `setUp`-is going to be executed before each test
    setUp(() {
      final accountMock = AccountAppData(
        uuid: '1',
        title: 'test',
        type: AppAccountType.account.toString(),
      );
      mock = AccountRecalculation(
        initial: accountMock.clone(),
        change: accountMock.clone(),
      );
    });
    // Define "table" of input arguments and output assertions
    final testCases = [
      // initial  |   change   | result
      [false, 5.0,  false, 1.0,  -4.0],
      [false, 1.0,  false, 5.0,   4.0],
      [true,  2.0,  false, 3.0,   3.0],
      [false, 2.0,  true,  3.0,  -2.0],
    ];
    // Run all defined Test Cases
    for (var v in testCases) {
      test('initial(hidden[${v[0]}], details[${v[1]}]), change(hidden[${v[2]}], details[${v[3]}]) => ${v[4]}', () {
        // Update inputs
        mock.initial!.hidden = v[0] as bool;
        mock.initial!.details = v[1] as double;
        mock.change.hidden = v[2] as bool;
        mock.change.details = v[3] as double;
        // Assert `AccountRecalculation.getDelta`-method results
        expect(mock.getDelta(), v[4]); 
      });
    }
  });
}
\end{lstlisting}

By typing `flutter test` in the command line we would see something like that:

\begin{lstlisting}
[V] Given Main page When tap on Create Then opened BillAddPage
[V] Account Recalculation:getDelta initial(hidden[false], details[5.0]), change(hidden[false], details[1.0]) => -4.0
[V] Account Recalculation:getDelta initial(hidden[false], details[1.0]), change(hidden[false], details[5.0]) => 4.0
Expected: <3.0>
  Actual: <1.0>
[X] Account Recalculation:getDelta initial(hidden[true], details[2.0]), change(hidden[false], details[3.0]) => 3.0
[V] Account Recalculation:getDelta initial(hidden[false], details[2.0]), change(hidden[true], details[3.0]) => -2.0
Null check operator used on a null value
[X] Account Recalculation:getDelta initial(null), change(hidden[false], details[2.0]) => 2.0
Exited (1)
\end{lstlisting}

\noindent That test has highlighted a dozen of troubles and failures in our code, so, it definitely has not been 
written in vain.

\begin{lstlisting}[firstnumber=17]
// ./lib/_classes/data/account_recalculation.dart
double getDelta() {
  return change.hidden
\end{lstlisting}
{
\xpretocmd{\lstlisting}{\vspace{-12pt}}{}{}
\begin{lstlisting}[firstnumber=20, backgroundcolor=\color{backred}]
(*@\kdiff{-}@*)  ? -initial!.details
\end{lstlisting}
\begin{lstlisting}[firstnumber=20, backgroundcolor=\color{backgreen}]
(*@\kdiff{+}@*)  ? -(initial?.details ?? 0.0)
\end{lstlisting}
\begin{lstlisting}[firstnumber=21, backgroundcolor=\color{backred}]
(*@\kdiff{-}@*)  : change.details - initial!.details;
\end{lstlisting}
\begin{lstlisting}[firstnumber=21, backgroundcolor=\color{backgreen}]
(*@\kdiff{+}@*)  : (initial?.hidden ?? true
(*@\kdiff{+}@*)      ? change.details
(*@\kdiff{+}@*)      : change.details - initial?.details);
\end{lstlisting}
\begin{lstlisting}[firstnumber=24]
}
\end{lstlisting}
}

\subsubsection{Creating Automated Quality Gates}

Tests writing is not enough for a quality check, we have to implement some dozen of automation till the phase 
when will become too lazy to trigger that manually. In addition, Flutter provides a couple of commands for the 
code improvement:
\begin{lstlisting}
flutter analyze // Static analysis of Dart code
dart format // Apply rules from https://dart.dev/effective-dart/style#formatting
dart fix // Check what can be improved, by `--apply` will change the code
\end{lstlisting}

\paragraph{Creating Git Hooks}

Someone might think that additional checks before `git commit` and `git push` will slowdown the development process, 
contrary that minimizes pushes back and forward to resolve failures on CI/CD build procedure. For a really big projects
that might take hours in contrast with seconds on local environment. Surely, the automation process has to be done
accurately and properly, otherwise it will be constantly bored.

Implementing git hooks is a preparation of bash-scripts for execution, so, let's discuss here `pre-push`-file (since
`pre-commit`-file contains almost the same logic for another scope of commands).

\begin{lstlisting}[language=bash]
#!/bin/bash

status=0

flutter test # Trigger tests
status_test=$? # Take status for lastly executed command

if [ $status_test -ne 0 ]; then
  echo "[x] flutter test - failed."
  status=1
else
  echo "[+] flutter test - passed."
fi

exit $status
\end{lstlisting}

\noindent Let's use Grinder to install our hooks (`dart run grinder:init` can be used to generate a skeleton 
structure if it's missing yet).

\begin{lstlisting}
// ./tool/grind.dart
import 'dart:io';
import 'package:path/path.dart' as path;
import 'package:grinder/grinder.dart';

main(args) => grind(args);

@Task('Install Git Hooks')
installGitHooks() {
  final currDir = Directory('./');
  final hookDir = Directory('./.git/hooks');
  final hookNames = ['pre-commit', 'pre-push'];
  for (final name in hookNames) {
    log('Applying: $name');
    final sourceFile = File(path.join(currDir.absolute.path, name));
    sourceFile.copySync(path.join(hookDir.absolute.path, name));
  }
  log('Git Hooks applied!');
}
\end{lstlisting}

\noindent After that by using command line, let's check what we have:

\begin{lstlisting}[language=bash]
$ dart run grinder -h
Dart workflows, automated.

Usage: grinder [options] [<tasks>...]

Global options:
  --no-color           Whether to use terminal colors.
  --version            Reports the version of this tool.
  -h, --help           Print this usage information.

Available tasks:
  install-git-hooks    Install Git Hooks
  sort-translations    Update Translations by sorting values alphabetically

$ dart run grinder install-git-hooks
  grinder running install-git-hooks
  
  install-git-hooks
    Applying: pre-commit
    Applying: pre-push
    Git Hooks applied!
  
  finished in 0.0 seconds

$ git add .
$ git commit -m "Sample Commit"
Computing fixes in app-finance (dry run)...
Nothing to fix!
Formatted 56 files (0 changed) in 0.42 seconds.

[+] dart fix - passed.
[+] dart format - passed.
[+] dart run grinder sort-translations - passed.
Sample Commit
 3 files changed, 65 insertions(+), 90 deletions(-)

$ git push
# ... logs from tests
[+] flutter test - passed.
# ... other logs from git
\end{lstlisting}


\paragraph{Adding Grinder Helpers}

We haven't yet discussed our `grinder sort-translations` that was shown through the logs above. That task is needed
to automatically rearrange our labels in `/lib/l10n/app\_*.arb`-files. We might extend our grinder tasks lately
by also checking consistency (enter missing labels across the `.arb`-files), exporting labels to `.scv`-file
for translation purposes, and importing them back.

\begin{lstlisting}
// ./tool/grind.dart
import './localization.dart' as locale;

@Task('Update Translations by sorting values alphabetically')
sortTranslations() {
  // Get all additional arguments for the command
  TaskArgs args = context.invocation.arguments;
  // Run: dart run grinder sort-translations --quiet
  bool isQuiet = args.getFlag('quiet'); // Returns `true` if set
  bool isChanged = locale.sortArbKeys('./lib/l10n');
  if (isChanged && !isQuiet) {
    fail('Changes detected'); // (!) to handle failure
  }
}
\end{lstlisting}

\begin{lstlisting}
// ./tool/localization.dart
import 'dart:convert';
import 'dart:io';
import 'package:grinder/grinder.dart';

bool sortArbKeys(String path) {
  log('Checking $path'); // Add to console output the text
  final arbDir = Directory(path);
  bool isChanged = false;
  // Check, that folder is not missing
  if (!arbDir.existsSync()) {
    log('Error: Directory not found');
    return true;
  }
  // Loop per each file there
  for (var file in arbDir.listSync()) {
    // Take only .arb-files
    if (file is File && file.path.endsWith('.arb')) {
      log('- ${file.path}');
      // `|=` is a boolean OR assignment
      isChanged |= sortArbFileKeys(file);
    }
  }
  log(isChanged ? 'Labels reordered' : 'Nothing was changed');
  return isChanged;
}

bool sortArbFileKeys(File file) {
  // Load data from file
  final jsonContent = file.readAsStringSync();
  final arbMap = json.decode(jsonContent) as Map<String, dynamic>;
  // Sort labels
  final entries = arbMap.entries.toList();
  entries.sort((a, b) {
    final aKey = a.key.startsWith('@') ? a.key.substring(1) : a.key;
    final bKey = b.key.startsWith('@') ? b.key.substring(1) : b.key;
    return aKey.compareTo(bKey);
  });
  final sortedArbMap = Map.fromEntries(entries);
  // Write back to the file with preserved indentation
  const encoder = JsonEncoder.withIndent('    ');
  var jsonOutputContent = encoder.convert(sortedArbMap);
  file.writeAsStringSync(jsonOutputContent);
  return jsonOutputContent != jsonContent; // Check if changed
}
\end{lstlisting}

\paragraph{Activating GitHub Workflow}

We've done with our automation for local environment, let's go further and define quality gates on GitHub repository.

\begin{lstlisting}[language=yaml]
# ./.github/workflows/dart.yml
name: Flutter/Dart Quality Gates # Name that would be shown in Actions tab

on:
  push: # Trigger after a merge
    branches: [ "main" ] # limit to main-branch
  pull_request: # Trigger on pull-request
    branches: [ "main" ] # if the target is main-branch

jobs:
  build:
    runs-on: ubuntu-latest # Environment for execution

    steps:
      - uses: actions/checkout@v3 # Checkout from repository
      - uses: subosito/flutter-action@v2 # Install Flutter/Dart
        with:
          channel: 'stable'
      - run: flutter --version # Show version in logs

      - name: Install Dependencies
        run: flutter pub get

      - name: Verify Formatting
        run: dart format --output=none --set-exit-if-changed .

      - name: Check Localizations ordering
        run: dart run grinder sort-translations

      # Consider passing '--fatal-infos' for slightly stricter analysis.
      - name: Analyze Project Source
        run: flutter analyze

      - name: Run tests
        run: flutter test
\end{lstlisting}

\noindent By preparing a pull-request we would see next representative validations flow 
(\cref{img:pt-github}, \cref{img:pt-github-details})):

\img{prototyping/github-check}{GitHub Toolbar on pull-request}{img:pt-github}

\img{prototyping/github-check-details}{GitHub Workflow Actions details}{img:pt-github-details}

In which way we can improve the current state is to gratitude ourselves by Badges of Workflow Status and Code Coverage.

\begin{lstlisting}[language=bash]
# ./README.md
# Notation of an image with tooltip "Build Status" 
![Build Status](https://github.com/{user}/{repo}/actions/workflows/{workflow-name}.yml/badge.svg?branch=main)
# Notation of an image with a link to our repository
[![Tests Coverage](https://{user}.github.io/{repo}/coverage_badge.svg)](https://github.com/{user}/{repo})
\end{lstlisting}

`Build Status` is supported out of the box (OOTB) by GitHub, just it's needed to replace `\{user\}` (account name
on GitHub), `\{repo\}` (repository name), and `\{workflow-name\}` (name of the file in `.github/workflows`-folder).

`Test Coverage` is needed to be cooked (there are many ways to do that and none of them is universal), and we're 
starting from creating `gh-pages` for our repository (drop hooks from `.git/hooks`-folder if they've been enabled):

\begin{lstlisting}[language=bash]
git switch --orphan gh-pages
git commit --allow-empty -m "Initial commit"
git push -u origin gh-pages
git checkout main
\end{lstlisting}

\noindent That will create for us a special branch that is accessible via \`https://\{user\}.github.io/\{repo\}\`-link. 
Then we need to extend our GitHub Workflow by including there a section to upload artifacts:

\begin{lstlisting}[language=yaml]
# ./.github/workflows/dart.yml
# Updating previously created step by a conditional execution
- name: Run tests
run: |
  if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
    flutter test --coverage
    dart run grinder coverage-badge # New Grinder task to generate `.svg'-file with coverage
  else
    flutter test
  fi
# New section to upload artifacts
- name: Update Coverage Badge
  # Get default branch variable and compare with current
  if: github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
  uses: peaceiris/actions-gh-pages@v3 # Special action to upload artifacts
  with:
    github_token: ${{ secrets.GITHUB_TOKEN }} # Generated automatically by GitHub
    publish_dir: ./coverage # Folder to upload
\end{lstlisting}

\img{prototyping/badges}{Generated README.md for the repository}{img:pt-badge}

Everything is done (\cref{img:pt-badge})... almost. Coverage 46\% is unbelievable for written tests. The problem is 
that untouched (by tests) files are not included into the report. And, additionally, widget tests cover most of the 
files without checking them. So, let's separate type of tests' execution, and provide additional Grinder task to 
touch all our files for the coverage report.

\begin{lstlisting}[language=yaml]
# ./.github/workflows/dart.yml
- name: Run tests
  run: |
    if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
      dart run grinder full-coverage
      flutter test --coverage test/unit
      flutter test test/widget
      dart run grinder coverage-badge
    else
      flutter test
    fi
\end{lstlisting}

\begin{lstlisting}
// ./tool/coverage.dart
import 'dart:io';
void scanDirectory(Directory directory, List<String> files) {
  directory.listSync(recursive: true).forEach((entity) {
    if (entity is File && // Check that it's a file
        entity.path.endsWith('.dart') && // Include only Dart
        !entity.path.endsWith('.g.dart')) { // Code generation
      files.add(entity.absolute.path
        .replaceAll(root.absolute.path, '') // Cut out root prefix
        .replaceAll('\\', '/')); // Fix for Windows' systems
    } else if (entity is Directory) {
      scanDirectory(entity, files); // Recursively scan further
    }
  });
}
\end{lstlisting}

\begin{lstlisting}
// ./tool/grind.dart
import './coverage.dart' as coverage;
@Task('Generate file with all lib/**.dart-files included')
fullCoverage() {
  List<String> files = [];
  String content = "// AUTOGENERATED BY `dart run grinder full-coverage` \n";
  final rootFolder = Directory('${Directory.current.path}/lib');
  coverage.scanDirectory(rootFolder, rootFolder, files);
  for (var file in files) {
    content += "import 'package:app_finance$file';\n";
  }
  content += "void main() {}\n";
  File(path.join(Directory.current.path, 'test/_coverage.dart')).writeAsStringSync(content);
}
\end{lstlisting}

\begin{lstlisting}[language=bash]
# .gitignore
# Coverage report
coverage/
test/_coverage.dart
\end{lstlisting}

\noindent 10\% Coverage... here we are. Slowly and progressively, we will correct this assessment but not immediately.
Do remember that we're on an early stage and nothing is neither stable, nor finalized yet.