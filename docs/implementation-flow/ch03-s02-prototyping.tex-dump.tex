% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.


Question: how to extend TextTheme with own parameters

Answer: To extend the TextTheme in Flutter with your own custom parameters, you can create a new TextTheme instance 
and provide values for the desired properties.

\begin{lstlisting}
TextTheme myTextTheme = TextTheme(
  headline1: TextStyle(fontSize: 32, fontWeight: FontWeight.bold),
  headline2: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
  numberLarge: TextStyle(fontSize: 48, fontWeight: FontWeight.bold), // Custom property
);
\end{lstlisting}

In this example, we create a new TextTheme called myTextTheme. We define the headline1 and headline2 properties with 
custom font sizes and font weights. Additionally, we add a custom property called numberLarge with a larger font size.

However, please note that the error you mentioned (The named parameter 'numberLarge' isn't defined) occurs because 
numberLarge is not a built-in property of TextTheme. To define custom properties, you need to create your own 
extension of the TextTheme class.

Here's an example of how you can create a custom extension of TextTheme:

\begin{lstlisting}
extension MyTextTheme on TextTheme {
  TextStyle get numberLarge => TextStyle(fontSize: 48, fontWeight: FontWeight.bold);
}
\end{lstlisting}

By using an extension, you can define additional properties or methods for the TextTheme class. In this case, 
the numberLarge property is added to the TextTheme class, allowing you to access it directly from an instance of 
TextTheme.

You can then use your custom TextTheme and the extended properties in your app as follows:

\begin{lstlisting}
MaterialApp(
  theme: ThemeData(
    textTheme: myTextTheme,
  ),
  // other app configuration
)
\end{lstlisting}

By setting the textTheme property of your app's ThemeData to your custom TextTheme instance, you can apply the 
extended properties throughout your app.

To have an effect inside different files do not forget to include the theme:
\begin{lstlisting}
import 'package:app_finance/custom_text_theme.dart';
\end{lstlisting}

Otherwise your customizations won't be visible.



Question: will use theme dark and light modes?

Answer: to extend the TextTheme for both dark and light modes

\begin{lstlisting}
extension MyTextTheme on TextTheme {
  TextStyle get numberLarge => TextStyle(fontSize: 48, fontWeight: FontWeight.bold);
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      theme: ThemeData.light().copyWith(
        textTheme: TextTheme().apply(
          bodyColor: Colors.black, // Customize text color for light mode
        ),
      ),
      darkTheme: ThemeData.dark().copyWith(
        textTheme: TextTheme().apply(
          bodyColor: Colors.white, // Customize text color for dark mode
        ),
      ),
      themeMode: ThemeMode.system, // Use system theme mode (light or dark based on device settings)
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(
          'My App',
          style: Theme.of(context).textTheme.headline6,
        ),
      ),
      body: Center(
        child: Text(
          'Hello, World!',
          style: Theme.of(context).textTheme.numberLarge,
        ),
      ),
    );
  }
}
\end{lstlisting}

In this example, we extend the TextTheme using the MyTextTheme extension. Then, in the MyApp widget, we configure the 
light and dark themes by customizing the text color for each mode using the bodyColor property. We set the themeMode 
to ThemeMode.system to follow the system's light or dark mode based on device settings.

Inside the MyHomePage widget, we use the Theme.of(context) to access the appropriate theme's TextTheme and apply 
the extended numberLarge style to the Text widget.

By using this approach, the text style defined in the numberLarge extension will automatically adapt to the chosen 
theme mode (light or dark) without needing separate extensions for each mode.


Question: TextTheme.copyWith to update only font size

Answer: To update only the font size of a TextTheme while keeping the other properties intact, you can use the 
copyWith method. 

\begin{lstlisting}
class CustomTextTheme {
    static TextTheme? createCustomTextTheme(TextTheme? baseTheme) {
        if (baseTheme == null) {
        return null;
        }
        
        return baseTheme.copyWith(
        headline1: baseTheme.headline1!.copyWith(fontSize: 32, fontWeight: FontWeight.bold),
        headline2: baseTheme.headline2!.copyWith(fontSize: 24, fontWeight: FontWeight.bold),
        // Add your custom text styles here
        );
    }
}     
\end{lstlisting}

In this updated example, the createCustomTextTheme function accepts a nullable baseTheme. It checks if the 
baseTheme is null and returns null in that case. Otherwise, it proceeds to create a modified copy of the 
baseTheme with your custom text styles applied.

To use this custom text theme in your app, you can pass CustomTextTheme.myTextTheme to the textTheme property of 
your app's ThemeData:

\begin{lstlisting}
MaterialApp(
    theme: ThemeData(
        textTheme: CustomTextTheme.createCustomTextTheme(Theme.of(context).textTheme),
    ),
    // Other app configurations
)   
\end{lstlisting}

By using this approach, you can generate a custom TextTheme by invoking the updated utility function that accepts a 
nullable TextTheme and returns a nullable TextTheme.


Question: Flutter set default locale if not found

\begin{lstlisting}
MaterialApp(
  ...
  localizationsDelegates: AppLocalizations.localizationsDelegates,
  supportedLocales: AppLocalizations.supportedLocales,
  ...
)
\end{lstlisting}



Question: how to convert
\begin{lstlisting}
var menuList = [
  (
    name: 'Home',
    icon: Icons.home,
    route: homeRoute,
  ),
  (
    name: 'Goals',
    icon: Icons.star,
    route: homeRoute,
  )
];
\end{lstlisting}
to PopupMenuButton

To convert the menuList to a PopupMenuButton widget, you can map each item in the list to a PopupMenuItem widget. 

\begin{lstlisting}
PopupMenuButton(
  itemBuilder: (BuildContext context) {
    return menuList.map((menuItem) {
      return PopupMenuItem(
        child: Row(
          children: [
            Icon(menuItem['icon']),
            SizedBox(width: 8),
            Text(menuItem['name']),
          ],
        ),
        value: menuItem['route'],
      );
    }).toList();
  },
  onSelected: (value) {
    // Handle the selected route
    // You can navigate to the selected route using Navigator.pushNamed(context, value)
    Navigator.pushNamed(context, value);
  },
  icon: Icon(Icons.more_vert),
)
\end{lstlisting}

In this example, menuList is mapped to a list of PopupMenuItem widgets using the map method. Each PopupMenuItem 
contains a Row with an Icon and Text widget to display the icon and name from each item in the menuList. 
The value property of PopupMenuItem is set to the route value from each item.

When a menu item is selected, the onSelected callback is triggered with the selected route value. In this example,
Navigator.pushNamed is used to navigate to the selected route.


Question: Drawer icon change

Answer: To change the drawer icon in Flutter, you can use the IconButton widget along with the Scaffold widget. 

\begin{lstlisting}
Scaffold(
  appBar: AppBar(
    title: Text('My App'),
    leading: IconButton(
      icon: Icon(Icons.menu),
      onPressed: () {
        // Open the drawer
        Scaffold.of(context).openDrawer();
      },
    ),
  ),
  drawer: Drawer(
    // Drawer content goes here
  ),
  // Other body content of the scaffold
)
\end{lstlisting}

In this example, the leading property of the AppBar is set to an IconButton with the Icons.menu icon. When the 
icon is pressed, the onPressed callback is triggered, and the openDrawer() method is called to open the drawer.

Make sure to wrap the Scaffold widget with a Builder widget if you're using this code inside a function 
where the context is not directly available.





Question: Scaffold.of(context).openDrawer() leads to error Scaffold.of() called with a context that does 
not contain a Scaffold.

The error "Scaffold.of() called with a context that does not contain a Scaffold" occurs when you try to access 
the Scaffold widget using the Scaffold.of() method but the BuildContext you provide does not have a Scaffold 
widget as an ancestor.

To resolve this error, make sure that you are calling Scaffold.of() within a context where a Scaffold widget 
exists. Here are a few possible solutions:

Wrap the widget that contains the Scaffold.of() call with a Builder widget:

\begin{lstlisting}
Builder(
  builder: (BuildContext context) {
    return YourWidget(
      onPressed: () {
        Scaffold.of(context).openDrawer();
      },
    );
  },
)
\end{lstlisting}

If the widget that contains the Scaffold.of() call is already inside a Builder widget, ensure that the BuildContext 
passed to Scaffold.of() is the correct one. Double-check that you are using the correct BuildContext in your code.

If you are trying to open the drawer from a different widget, you can consider using a callback or state management 
approach. Pass a callback function from the parent widget that owns the Scaffold to the child widget, and call that 
function to trigger the drawer opening.




Error: For some reasons from AccountEditPageState widget.uuid is not accessible, and fails with an error The getter 
'uuid' isn't defined for the type 'AccountAddPage'.

\begin{lstlisting}
import 'package:flutter/material.dart';

class AccountEditPage extends AccountAddPage {
  String uuid;

  AccountEditPage({
    required this.uuid,
  }) : super();

  @override
  AccountEditPageState createState() => AccountEditPageState();
}

class AccountEditPageState extends AccountAddPageState<AccountEditPage> {
  String get uuid => widget.uuid; // ERROR: The getter 'uuid' isn't defined for the type 'AccountAddPage'.
}


class AccountAddPage extends AbstractPage {
  String? title;

  AccountAddPage({
    this.title,
  }) : super();

  @override
  AccountAddPageState createState() => AccountAddPageState();
}

class AccountAddPageState<T extends AccountAddPage> extends AbstractPageState<AccountAddPage> {
  String? get title => widget.title; // OK
}


abstract class AbstractPage<T> extends StatefulWidget {
  int selectedMenu = 0;
  // Be accurate with \q{UniqueKey}-method usage for nested widgets
  // That will trigger \q{initState} each time of store updates 
  AbstractPage() : super(key: UniqueKey());
}

abstract class AbstractPageState<T extends AbstractPage> extends State<T> {
  @override
  Widget build(BuildContext context) {
    return Text('test');
  }
}
\end{lstlisting}

Resolution - (widget as AccountEditPage).uuid


Question: do we have enum for Flutter

Answer: Yes, Flutter provides an enum class that you can use to define enumerations. Enums in Flutter work similarly to 
enums in other programming languages. You can use enums to define a set of named values, and each value represents 
a constant.

\begin{lstlisting}
enum Color {
  red,
  green,
  blue,
}

void main() {
  Color myColor = Color.red;

  switch (myColor) {
    case Color.red:
      print('Selected color: Red');
      break;
    case Color.green:
      print('Selected color: Green');
      break;
    case Color.blue:
      print('Selected color: Blue');
      break;
  }
}
\end{lstlisting}

In this example, we defined an enum called Color with three possible values: red, green, and blue. We created a 
variable myColor and assigned it the value Color.red. Then, using a switch statement, we checked the value of 
myColor and printed a corresponding message based on the selected color.

To validate function arguments using an enum in Flutter, you can define the function parameter with the enum type and 
use a switch statement to handle the different enum values.

\begin{lstlisting}
enum Status {
  active,
  inactive,
  pending,
}

void processStatus(Status status) {
  switch (status) {
    case Status.active:
      print('Processing active status');
      // Perform actions for active status
      break;
    case Status.inactive:
      print('Processing inactive status');
      // Perform actions for inactive status
      break;
    case Status.pending:
      print('Processing pending status');
      // Perform actions for pending status
      break;
  }
}

void main() {
  Status myStatus = Status.active;

  processStatus(myStatus);
}
\end{lstlisting}

In this example, we defined an enum called Status with three possible values: active, inactive, and pending. The 
processStatus function takes a parameter of type Status. Inside the function, we use a switch statement to 
handle each possible status value and perform the corresponding actions.

In the main function, we created a variable myStatus and assigned it the value Status.active. We then passed 
myStatus as an argument to the processStatus function, which will execute the appropriate code block based on 
the provided enum value.

By using enums in function parameters, you can enforce valid enum values and provide clear validation and handling 
for each possible value within the function.

you can use the toString() method of the AppAccountType enum to convert it to a string representation.

To convert a string representation back to an enum in Flutter, you can use the AppAccountType.values property and a 
loop or a lookup map to match the string with the corresponding enum value.

\begin{lstlisting}
enum AppAccountType {
  type1,
  type2,
  type3,
}

void main() {
  String accountTypeString = AppAccountType.type1.toString(); // Convert enum to string

  // Option 1: Use a loop to match the string with the enum value
  AppAccountType? accountType;
  for (var value in AppAccountType.values) {
    if (value.toString() == accountTypeString) {
      accountType = value;
      break;
    }
  }
  print('Converted enum value: $accountType');

  // Option 2: Use a lookup map to match the string with the enum value
  final accountTypeMap = {
    'type1': AppAccountType.type1,
    'type2': AppAccountType.type2,
    'type3': AppAccountType.type3,
  };
  AppAccountType? accountTypeFromMap = accountTypeMap[accountTypeString];
  print('Converted enum value from map: $accountTypeFromMap');
}
\end{lstlisting}

In this example, we start with a string representation of the AppAccountType.type1 enum value using 
AppAccountType.type1.toString().

Option 1 demonstrates how to match the string with the enum value using a loop. We iterate over the 
AppAccountType.values property and compare each enum's string representation with the desired string. 
If a match is found, we assign the corresponding enum value to the accountType variable.

Option 2 shows how to use a lookup map to match the string with the enum value. We define a map where the keys 
are the string representations of the enum values, and the values are the actual enum values. We then use the 
string representation as the key to retrieve the enum value from the map.

