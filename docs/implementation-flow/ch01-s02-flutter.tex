% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

\markboth{Bootcamping Flutter}{Bootcamping Flutter}

[TBD]


\subsubsection{Asserting Functions Definition}

By defining functions as arguments for widgets, we can use then as an expectation of functions structure.

\begin{lstlisting}
typedef SetViewFunction = String Function(Currency input);

class CurrencySelector extends StatelessWidget {
  SetViewFunction? setView;

  CurrencySelector({
    Key? key,
    this.setView,
  }) {
    setView ??= setDefaultView;
  }

  String setDefaultView(Currency input) {
    // Default implementation
  }
}
\end{lstlisting}


\subsubsection{Ignoring Function Arguments}

Not required fields are specified slightly different in comparison with classes constructors:

\begin{lstlisting}
void add(String value, [int? id]);
\end{lstlisting}


\subsubsection{Applying Getters and Setters for Class Variables}

By migrating our data structures to class objects it can be used additionally getter and setter for class variables.
That will help us to cover, as an example, \q{description}-attribute for Budget structures by showing 
"Spent Amount / Total Budget", and for \q{details}-attribute - "Left Amount".

\begin{lstlisting}
class MyClass {
  String _name; // Private variable

  // Getter for name
  String get name => _name;

  // Setter for name
  set name(String value) {
    _name = value;
  }
}

void main() {
  MyClass myObject = MyClass();

  // Using the setter
  myObject.name = 'John';

  // Using the getter
  print(myObject.name); // Output: John
}
\end{lstlisting}

In the example above, the \q{MyClass}-class has a private variable \q{\_name}. The getter for \q{\_name} is defined 
using the get keyword, and the setter is defined using the set keyword. The getter returns the value of 
\q{\_name}, and the setter sets the value of \q{\_name} to the provided value. By using that approach we can control 
the access to class variables and perform additional logic or validation when getting or setting their values.

One more question, is how to set \q{DateTime.now()} inside a constructor as default value, since, by defining it inside
the constructor, an error would be taken: The default value of an optional parameter must be constant.

So, to set a default value for a DateTime variable as the current date and time, we can use the \q{DateTime.now()} method 
during the initialization of the variable.

\begin{lstlisting}
class MyClass {
    DateTime _createdAt;

    MyClass({DateTime? createdAt})
        : _createdAt = createdAt ?? DateTime.now();

    DateTime get createdAt => _createdAt;
}
\end{lstlisting}


\subsubsection{Using cast to resolve dynamic structures}

Migration our Bills to classes construction has lead to an error on .firstWhere when Account of Budget not found. 
To resolve that we have to cast our getter (otherwise it would be an error: type '() => dynamic' is not a subtype 
of type '(() => BudgetAppData)?' of 'orElse') and add orElse operator as following:

\begin{lstlisting}
  dynamic getByUuid(AppDataType property, String uuid) {
    var scope = (_data[property] as Map)['list'];
    return scope.cast<dynamic>() // cast to cover different types, 
    .firstWhere(
      (item) => item.uuid == uuid,
      orElse: () => null, // Return null if not found
    );
  }
\end{lstlisting}


\subsubsection{Differentiating Map Types}

\q{HashMap}, as named, provides access to items by their hash in (potentially amortized) constant time.

\q{SplayTreeMap}' is based on a self-balancing binary tree that allows most single-entry operations in amortized 
logarithmic time.

\begin{lstlisting}
class SummaryAppData {
  // Tree provides improved state on sorting
  final _scope = SplayTreeMap<int, String>();
  // Hash gives us better performance to search by key
  final _hash = HashMap<String, int>();

  SummaryAppData({
    required List<String> list,
  }) {
    this.list = list; // Cover the original property by get/set
  }

  // Return list in reversed order
  List<String> get list => _scope.values.toList().reversed.toList();

  set list(List<String> list) {
    for (int i = 0; i < list.length; i++) {
      add(list[i], i + 1);
    }
  }

  add(String value, [int? id]) {
    // Checking that our UUIDs are unique across the list
    if (_hash.containsKey(value)) {
      _scope.remove(_hash[value]);
      _hash.remove(value);
    }
    // Used to sort the list based on last modification 
    int key = id ?? DateTime.now().millisecondsSinceEpoch;
    _scope[key] = value;
    _hash[value] = key;
  }
}
\end{lstlisting}