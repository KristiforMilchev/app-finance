% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

\subsection{Flutter}
\markboth{Bootcamping}{Flutter}


\subsubsection{Asserting Functions Definition}

By defining functions as arguments for widgets, we can use then as an expectation of functions structure.

\begin{lstlisting}
typedef SetViewFunction = String Function(Currency input);

class CurrencySelector extends StatelessWidget {
  SetViewFunction? setView;

  CurrencySelector({
    Key? key,
    this.setView,
  }) {
    setView ??= setDefaultView;
  }

  String setDefaultView(Currency input) {
    // Default implementation
  }
}
\end{lstlisting}


\subsubsection{Ignoring Function Arguments}

Not required fields are specified slightly different in comparison with classes constructors:

\begin{lstlisting}
void add(String value, [int? id]);
\end{lstlisting}


\subsubsection{Using cast to resolve dynamic structures}

Migration our Bills to classes construction has lead to an error on .firstWhere when Account of Budget not found. 
To resolve that we have to cast our getter (otherwise it would be an error: type '() => dynamic' is not a subtype 
of type '(() => BudgetAppData)?' of 'orElse') and add orElse operator as following:

\begin{lstlisting}
  dynamic getByUuid(AppDataType property, String uuid) {
    var scope = (_data[property] as Map)['list'];
    return scope.cast<dynamic>() // cast to cover different types, 
    .firstWhere(
      (item) => item.uuid == uuid,
      orElse: () => null, // Return null if not found
    );
  }
\end{lstlisting}


\subsubsection{Differentiating Map Types}

\q{HashMap}, as named, provides access to items by their hash in (potentially amortized) constant time.

\q{SplayTreeMap}' is based on a self-balancing binary tree that allows most single-entry operations in amortized 
logarithmic time.

\begin{lstlisting}
class SummaryAppData {
  // Tree provides improved state on sorting
  final _scope = SplayTreeMap<int, String>();
  // Hash gives us better performance to search by key
  final _hash = HashMap<String, int>();

  SummaryAppData({
    required List<String> list,
  }) {
    this.list = list; // Cover the original property by get/set
  }

  // Return list in reversed order
  List<String> get list => _scope.values.toList().reversed.toList();

  set list(List<String> list) {
    for (int i = 0; i < list.length; i++) {
      add(list[i], i + 1);
    }
  }

  add(String value, [int? id]) {
    // Checking that our UUIDs are unique across the list
    if (_hash.containsKey(value)) {
      _scope.remove(_hash[value]);
      _hash.remove(value);
    }
    // Used to sort the list based on last modification 
    int key = id ?? DateTime.now().millisecondsSinceEpoch;
    _scope[key] = value;
    _hash[value] = key;
  }
}
\end{lstlisting}