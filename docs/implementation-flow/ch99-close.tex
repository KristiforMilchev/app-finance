% Copyright 2023 The terCAD team. All rights reserved.
% Use of this content is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

Reflecting on the progress we've made and the tools we've honed, the question emerges: is Flutter a commendable 
choice for developing platform-agnostic solutions? Well, as regarding recommendations on technologies and approaches, 
the answer invariably begins with those two words: "it depends".

With the advent of microservices, a software architecture paradigm that breaks an application into smaller, 
interconnected parts, it resolved the majority of the maintenance and development hurdles associated with monolithic 
architectures, where everything functions as a single system. Nonetheless, in this transformation, microservices 
ushered in a new set of requirements for engineering teams, necessitating higher levels of proficiency in practices 
and processes \cite{Mugr23}.

Regarding the argument of "hot reload" as a game-changing feature, it primarily holds substantial value during the 
initial stages of a design and implementation process. However, when it comes to delivering fully functional solutions, 
the emphasis shifts to the importance of rigorous testing and adaptability. In addition, Flutter introduces 
Dart-language, which may require some practice to become proficient.

In the landscape of the platform-agnostic application development, there are a dozen other solutions to consider,
including React Native, Kotlin Multiplatform Mobile, Kivy, Xamarin, Swiftic, Ionic, Apache Cordova, NativeScript,
Onsen UI, Framework 7, Mobile Angular UI, Avalonia UI, .NET MAUI, and several lesser-known options. We shouldn't gauge
them by using a trivial "Hello, World!" application, which lacks real-world significance. It's time to address a
fundamental challenge in a software development as complexity (essential and accidental \cite{Broo87}), where we're
emphasizing essential complexity by minimizing accidental complexity. And, to my understanding, the accidental
complexity refers to the challenges posed by the tools and frameworks we use, such as Flutter, while essential
complexity is intrinsic to our specific implementation.

Revisiting our current implementation, as discussed in the previous pages of that book, it is as 
straightforward as it can be, with a clear declaration of business logic (that is quite simple). To put it plainly, 
we've covered the essential and less thrilling aspects of our application. Now, it's time to delve into integration 
protocols, intricate notifications, and automated intelligent analysis. There's no better way to begin this journey 
than by starting it together. I cordially invite you to join the project, where we can continue exploring Flutter and 
its vast capabilities side by side. This collaborative learning experience promises to be both exciting and educational 
as we delve deeper into this versatile framework.
