// Copyright 2023 The terCAD team. All rights reserved.
// Use of this source code is governed by a CC BY-NC-ND 4.0 license that can be found in the LICENSE file.

import 'dart:io';
import 'package:path/path.dart' as path;
import 'package:grinder/grinder.dart';
import './localization.dart' as locale;
import './coverage_badge.dart' as badge;
import './coverage.dart' as coverage;
import './git_history.dart' as git;

main(args) => grind(args);

@DefaultTask()
void defaultTask() {
  log('Run `dart run grinder -h` to view the list');
  log('Run `dart run grinder <taskName>` to execute the task');
}

@Task('Generate Mocks')
mock() {
  Process.runSync('dart', [
    'run',
    'build_runner',
    'clean',
  ]);
  ProcessResult build = Process.runSync('dart', [
    'run',
    'build_runner',
    'build',
    '--delete-conflicting-outputs',
  ]);
  if (build.exitCode > 0) {
    fail(build.stderr);
  }
  fixMock();
}

@Task('Fix Mocks by Dart Format')
fixMock() {
  final rootFolder = Directory('${Directory.current.path}/test');
  List<String> files = coverage.scanDirectory(rootFolder, rootFolder, '*.*.dart').map((path) => 'test$path').toList();

  Process.runSync('dart', ['format', '-l', '120', ...files]);
}

@Task('Run tests')
@Depends(mock)
test() {
  TaskArgs args = context.invocation.arguments;
  ProcessResult test = Process.runSync(
      'flutter',
      ['test', args.getFlag('coverage') ? '--coverage' : '', args.getOption('path') ?? '']
          .where((e) => e != '')
          .toList(),
      runInShell: true);
  String testResult = "\n${test.stdout}".replaceAll(RegExp(r'(?<=:\s).*\.dart: '), '');
  if (test.exitCode > 0) {
    fail(testResult);
  }
  log(testResult);
  if (args.getFlag('coverage')) {
    coverageBadge();
  }
}

@Task('Generate file with all lib/**.dart-files included')
fullCoverage() {
  TaskArgs args = context.invocation.arguments;
  String target = args.getOption('path') ?? '/_classes';
  String type = args.getOption('type') ?? 'unit';
  final content = StringBuffer();
  content.writeln("// AUTOGENERATED BY `dart run grinder full-coverage`");
  content.writeln('// ignore_for_file: unused_import');
  final rootFolder = Directory('${Directory.current.path}/lib$target');
  List<String> files = coverage.scanDirectory(rootFolder, rootFolder);
  for (var file in files) {
    content.writeln("import 'package:app_finance$target$file';");
  }
  content.writeln("void main() {}");
  File(path.join(Directory.current.path, 'test/$type/_coverage_test.g.dart')).writeAsStringSync(content.toString());
}

@Task('Generate Coverage Badge for README.md file')
coverageBadge() {
  TaskArgs args = context.invocation.arguments;
  String path = (args.getOption('path') ?? '').split('/').last;
  final lineCoverage = badge.calculateLineCoverage(File('coverage/lcov.info'));
  badge.generateBadge('${Directory.current.path}/coverage', lineCoverage, path);
}

@Task('Install Git Hooks')
installGitHooks() {
  final currDir = Directory('./');
  final hookDir = Directory('./.git/hooks');
  final hookNames = ['pre-commit', 'pre-push'];
  for (final name in hookNames) {
    log('Applying: $name');
    final sourceFile = File(path.join(currDir.absolute.path, name));
    sourceFile.copySync(path.join(hookDir.absolute.path, name));
    if (!Platform.isWindows) {
      Process.runSync('chmod', ['ug+x', './.git/hooks/$name']);
    }
  }
  log('Git Hooks applied!');
}

@Task('Update Translations by sorting values alphabetically')
sortTranslations() {
  TaskArgs args = context.invocation.arguments;
  bool isQuiet = args.getFlag('quiet');
  bool isChanged = locale.sortArbKeys('./lib/l10n');
  if (isChanged && !isQuiet) {
    fail('Changes detected');
  }
}

@Task('Generate Release Notes')
releaseNotes() {
  TaskArgs args = context.invocation.arguments;
  String tag = args.getOption('tag') ?? '0.0.0';
  String? output = args.getOption('output');
  String release = git.genRelease(tag);
  if (output != null) {
    final currDir = Directory('./');
    final file = File(path.join(currDir.absolute.path, output));
    file.writeAsStringSync(release);
  }
  log(release);
}

@Task('Patch PubSpec')
pubspecUpdate() {
  final dir = Directory('./');
  TaskArgs args = context.invocation.arguments;
  String build = args.getOption('build-name') ?? '0.0.0';
  String number = args.getOption('build-number') ?? '0';

  final spec = File(path.join(dir.absolute.path, 'pubspec.yaml'));
  spec.writeAsStringSync(spec
      .readAsStringSync()
      .replaceFirst('version: 1.0.0+1', 'version: $build+$number')
      .replaceFirst('msix_version: 1.0.0.1', 'msix_version: $build.$number'));

  final snap = File(path.join(dir.absolute.path, 'snapcraft.yaml'));
  snap.writeAsStringSync(snap.readAsStringSync().replaceFirst('version: 1.0.0+1', 'version: $build+$number'));
}

@Task('Export Translations')
exportTranslations() {
  log('TBD: Messages extracted successfully');
}

@Task('Update Localized Files')
importTranslations() {
  log('TBD: Localized files generated successfully');
}
